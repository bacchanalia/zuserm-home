#!/usr/bin/perl
use strict;
use warnings;
use Date::Parse qw(str2time);

sub parseLog();

my $dir = "/usr/local/crashplan";
my $guiExec = "$dir/bin/CrashPlanDesktop";
my $engineExec = "$dir/bin/CrashPlanEngine";
my $crashplanJar = "lib/com.backup42.desktop.jar";
my $cliWrapperSrc = "cliwrapper";
my $cliWrapperClass = "com.backup42.desktop.CliWrapper";
my $logFile = "$dir/log/history.log.0";

my @serviceCmds = qw(scan pause resume);
my $okServiceCmds = join "|", @serviceCmds;

my @engineCmds = qw(start stop restart status force-reload);
my $okEngineCmds = join "|", @engineCmds;
my $defaultCmd = "gui";
my $usage = "Usage:
  $0
  $0 -g|--gui
    run '$guiExec'

  $0 $okServiceCmds
    use custom CliWrapper to run the GUI 'CLI' commands in a REAL command line
    run 'cd $dir; java -cp $crashplanJar:$cliWrapperSrc $cliWrapperClass <ARG>'

  $0 $okEngineCmds
    run 'sudo $engineExec <ARG>'
";

sub main(@){
  my $cmd = shift if @_ > 0;
  $cmd = $defaultCmd if not defined $cmd;

  if($cmd =~ /^(-g|--gui|gui)$/ and @_ == 0){
    exec $guiExec;
  }elsif($cmd =~ /^($okEngineCmds)$/ and @_ == 0){
    exec "sudo", $engineExec, $cmd;
  }elsif($cmd =~ /^($okServiceCmds)$/ and @_ == 0){
    chdir $dir;
    exec "java", "-cp", "$crashplanJar:$cliWrapperSrc", $cliWrapperClass, $cmd;
  }else{
    die $usage;
  }
}

sub parseLog(){
  my @lines = `cat $logFile`;
  my $log = {};

  for my $line(@lines){
    my ($time, $backupName);
    if($line =~ /^I (\d\d)\/(\d\d)\/(\d\d) (\d\d):(\d\d)(AM|PM) \[(\w+)\]/){
      my ($mon, $day, $year, $hour, $min, $ampm, $name) = ($1, $2, $3, $4, $5, $6, $7);

      $time = str2time "$mon/$day/$year $hour:$min$ampm";
      $backupName = $name;
    }else{
      next;
    }

    my $dur = '(?:< )?\d+ (?:minute|hour|day)s?';
    my $n = '[0-9,]+';
    my $fs = '[0-9\.]+\s*[KMGT]?B';
    my $speed = '.*[0-9\.]+\s*[KMGT]?bps';

    my $entry;
    if($line =~ /Scanning for files to back up$/){
      $entry = {
        name => $backupName,
        time => $time,
        line => $line,
        type => "scan-start",
      }
    }elsif($line =~ /Scanning for files completed in ($dur): ($n) files? \(($fs)\) found$/){
      my ($duration, $fileCount, $size) = ($1, $2, $3);
      $entry = {
        name => $backupName,
        time => $time,
        line => $line,
        type => "scan-end",
        duration => $duration,
        filecount => $fileCount,
        size => $size,
      };
    }elsif($line =~ /Starting backup to CrashPlan Central: ($n) files? \(($fs)\) to back up$/){
      my ($fileCount, $size) = ($1, $2);
      $entry = {
        name => $backupName,
        time => $time,
        line => $line,
        type => "backup-start",
        filecount => $fileCount,
        size => $size,
      };
    }elsif($line =~ /(Stopped|Completed) backup to CrashPlan Central in ($dur): ($n) files? \(($fs)\) backed up, ($fs) encrypted and sent @ ($speed)(?: \(Effective rate: $speed\))?$/){
      my ($completestate, $duration, $fileCount, $size, $encsize, $speed) = ($1, $2, $3, $4, $5, $6);
      $entry = {
        name => $backupName,
        time => $time,
        line => $line,
        type => "backup-end",
        completestate => $completestate eq "Completed" ? "complete" : "incomplete",
        duration => $duration,
        filecount => $fileCount,
        size => $size,
        encsize => $encsize,
        speed => $speed,
      };
    }

    if(defined $entry and defined $$entry{filecount}){
      my $count = $$entry{filecount};
      $count =~ s/,//g;
      die "Malformed count: $count\n" if $count !~ /^\d+$/;
      $$entry{filecount} = $count;
    }

    if(defined $entry){
      $$log{$$entry{name}} = [] if not defined $$log{$$entry{name}};
      push @{$$log{$$entry{name}}}, $entry;
    }
  }
  return $log;
}

&main(@ARGV);
