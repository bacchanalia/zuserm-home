#!/usr/bin/perl
use strict;
use warnings;
use Time::HiRes qw(sleep);

my $logDir = "$ENV{HOME}/.cyphertite/logs";

my $backups = {
  backgrounds => '/home/wolke/Desktop/Backgrounds',
  dcim => '/home/wolke/Desktop/DCIM',
  documents => '/home/wolke/Desktop/Documents',
  games => '/home/wolke/Desktop/Games',
  music => '/media/stuff/Music',
  n9 => '/home/wolke/Code/n9',
  pictures => '/home/wolke/Desktop/Pictures',
  records => '/home/wolke/Desktop/Records',
};

sub getLatestLogFile($);
sub run(@);
sub bashComplete($$);

my $usage = "Usage:
  $0 NAME
     run 'ct-log NAME DIR'

  $0 --bash-complete COMP_LINE COMP_POINT
     print a list of words for bash completion
     COMP_LINE  - the full cmdline as a string
     COMP_POINT - the cursor position in the cmdline

  NAME => DIR:
    " . join("\n    ", map {"$_ => $$backups{$_}"} sort keys %$backups) . "
";

sub main(@){
  if(@_ == 3 and $_[0] =~ /^--bash-complete$/ and $_[2] =~ /^\d+$/){
    print join ' ', bashComplete($_[1], $_[2]);
    exit 0;
  }

  die $usage if @_ != 1 or not defined $$backups{$_[0]};
  my $ctfile = shift;
  my $dir = $$backups{$ctfile};
  if($dir !~ /^(.+)\/([^\/]+)$/){
    die "error parsing dir $dir\n";
  }
  my ($parent, $child) = ($1, $2);
  die "dir not found: $parent\n" if not -d $parent;
  chdir $parent;
  $ENV{PWD} = $parent;

  die "dir not found: $child\n" if not -d $child;

  my $oldLog = getLatestLogFile($ctfile);
  $oldLog = "" if not defined $oldLog;

  run "screen-cmd", "ct-log", $ctfile, $child;

  my $newLog = getLatestLogFile($ctfile);

  if(not defined $newLog or $newLog eq $oldLog){
    sleep 0.5;
    $newLog = getLatestLogFile($ctfile);
  }
  if(not defined $newLog or $newLog eq $oldLog){
    die "no log found for $ctfile\n";
  }
  chomp $newLog if defined $newLog;

  run "tail", "-F", $newLog;
}

sub getLatestLogFile($){
  my $ctfile = shift;
  my @files = sort `find $logDir -name ${ctfile}_*_*.log 2>/dev/null`;
  return @files == 0 ? undef : $files[-1];
}

sub run(@){
  print "@_\n";
  system @_;
}

sub bashComplete($$){
  my ($cmdLine, $pos) = @_;
  my $cmd = substr $cmdLine, 0, $pos;
  my $isNewWord = $cmd =~ /\s$/;
  $cmd =~ s/^\s+//;
  $cmd =~ s/\s+$//;

  my @words = split /\s+/, $cmd;
  shift @words;
  pop @words if not $isNewWord;

  my @names = sort keys %$backups;

  my @cmds = qw(
    --bash-complete
  );

  my @opts = qw(
  );

  if(@words == 0){
    return (@names, @cmds, @opts);
  }

  return ();
}

&main(@ARGV);
