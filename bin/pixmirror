#!/usr/bin/perl
#Copyright 2011,2012 by Elliot Wolk
#This is free software, released under the GPLv3
use strict;
use warnings;

sub findImages($);
sub statImage($);
sub getPix($);
sub checkInfo($$);
sub handleImage($$$$);
sub getNewPix($);
sub isOrientMatch($$);
sub getResizePercent($$$$);
sub pad($$$);
sub runConvert($@);
sub getOrientation($$);

my @exts = qw(jpg jpeg png);
my $convertExec = 'convert';
my $identifyExec = 'identify';
my $jheadExec = 'jhead';

my $targetX = 1920;
my $targetY = 1080;
my $targetOrientation = getOrientation $targetX, $targetY;
my $orientSwap = 0;

my $pad = 0;
my $padColor = 'black';
my $padGravity = 'center';
my $okGravity = join "|", split /\n+/, `$convertExec -list gravity 2>/dev/null`;

my $usage = "Usage:
  $0 [<OPTS>] <SRC_DIR> <DEST_DIR>
    Create a recursive copy of images from <SRC_DIR> to <DEST_DIR>,
      resized to fit <TARGET_X>x<TARGET_Y>, preserving original aspect ratios.

    The original filesize and modified timestamp are recorded for each file
      in a file with the same path as the original, appended with \".info\".
      If copies already exist on the target, they are not replaced unless the
      mtime or filesize of the original has changed, even if new arguments
      are given.

    Mirrored images are auto-rotated from EXIF metadata using '$jheadExec'

  <OPTS>
    --size=<TARGET_X>x<TARGET_Y>   {default is ${targetX}x${targetY}}
      target width and height in pixels {or height and width if src y>x}

    --orient  --no-orient          {default is --no-orient}
      Does not rotate the image.
      Permits the image to instead optionally fit in a <TARGET_Y>x<TARGET_X>
        frame, in order to be larger than if it fix in <TARGET_X>x<TARGET_Y>.
      If <TARGET_X>x<TARGET_X> is landscape-oriented and the source image
        is portrait-oriented {or vice-versa},
        <TARGET_X> and <TARGET_Y> are swapped.
      Landscape means x>y and portrait means y>=x.
      By default, the orientation is $targetOrientation {${targetX}x{$targetY}}
        {and can be changed with --size=<TARGET_X>x<TARGET_Y>}

    --pad  --no-pad                {default is --no-pad}
      Produce images that are exactly <TARGET_X>x<TARGET_Y> by padding
        with a solid black border on top/bottom or left/right.

    --pad-color=<COLOR>            {default is $padColor}
      when --pad is given, set the background to <COLOR>

    --pad-gravity=<GRAVITY>        {default is $padGravity}
      when padding, use gravity=<GRAVITY>
      <GRAVITY> is one of {$okGravity}
      e.g.: $0 --size=5000x50 --pad --pad-gravity=South
               append 4950 rows of black pixels to the top of a 50x50 image
";

sub main(@){
  while(@_ > 0 and $_[0] =~ /^-/){
    my $arg = shift;
    if($arg =~ /^--size=(\d+)x(\d+)$/){
      $targetX = $1+0;
      $targetY = $2+0;
      $targetOrientation = getOrientation $targetX, $targetY;
    }elsif($arg =~ /^--orient$/){
      $orientSwap = 1;
    }elsif($arg =~ /^--no-orient$/){
      $orientSwap = 0;
    }elsif($arg =~ /^--pad$/){
      $pad = 1;
    }elsif($arg =~ /^--no-pad$/){
      $pad = 0;
    }elsif($arg =~ /^--pad-color=(\w+)$/){
      $padColor = $1;
    }elsif($arg =~ /^--pad-gravity=($okGravity)$/i){
      $padGravity = $1;
    }else{
      die $usage;
    }
  }

  my $srcDir = shift;
  my $destDir = shift;

  die $usage if not defined $srcDir or not defined $destDir or @_ > 0;

  system "mkdir '$destDir' 2>/dev/null" if not -e $destDir;
  die "src '$srcDir' is not a directory" if not -d $srcDir;
  die "dest '$destDir' is not a directory" if not -d $destDir;

  system "which $convertExec > /dev/null";
  die "Could not exec $convertExec\n" if $? != 0;
  system "which $identifyExec > /dev/null";
  die "Could not exec $identifyExec\n" if $? != 0;

  my @srcImgs = findImages $srcDir;
  my $total = @srcImgs;

  print "running stat on $total images:\n";
  my %srcInfos;
  for my $img(@srcImgs){
    $srcInfos{$img} = statImage "$srcDir/$img";
  }

  print "comparing existing pixmirror info to src info:\n";
  my @destImgs = findImages $destDir;
  my %okImgs;
  for my $img(@destImgs){
    if(not checkInfo($srcInfos{$img}, "$destDir/$img.info")){
      print "removing $destDir/$img and $destDir/$img.info\n";
      system "rm", "$destDir/$img";
      system "rm", "$destDir/$img.info";
    }else{
      $okImgs{$img} = 1;
    }
  }

  @srcImgs = grep {not defined $okImgs{$_}} @srcImgs;
  my $toConvert = @srcImgs;
  my $skipped = $total - $toConvert;

  print "\nconverting $toConvert images {skipped $skipped}\n";
  for my $img(@srcImgs){
    handleImage $img, $srcDir, $destDir, $srcInfos{$img};
  }

  print "\n\nremoving empty dirs\n";
  system "cd \"$destDir\" && find -mindepth 1 -depth -type d -empty -delete";
}

sub findImages($){
  my $dir = shift;
  my @findArgs = join " -or ", map {"-iname '*.$_'"} @exts;

  my @imgs = `cd $dir; find @findArgs`;
  map {chomp} @imgs;
  return sort @imgs;
}

sub statImage($){
  my $img = shift;
  my @stat = stat $img;
  die "failed stat on '$img'\n" if @stat != 13;

  my ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,
    $atime,$mtime,$ctime,$blksize,$blocks) = @stat;
  return "$size|$mtime\n";
}

sub checkInfo($$){
  my ($srcInfo, $destInfoFile) = @_;
  if(not defined $srcInfo or not -e $destInfoFile){
    return 0;
  }

  open FH, "< $destInfoFile\n";
  my $destInfo = join '', <FH>;
  close FH;
  return $destInfo eq $srcInfo;
}

sub getPix($){
  my $file = shift;
  $file =~ s/'/'\\''/g;
  my $info = `identify -verbose '$file'`;
  if($info =~ /^\s*Geometry: (\d+)x(\d+)/m){
    return ($1, $2);
  }else{
    die "Could not find HxW using imagemagick for $file\n";
  }
}

sub handleImage($$$$){
  my ($img, $srcDir, $destDir, $statInfo) = @_;

  my $parent = "$destDir/$img";
  $parent =~ s/\/[^\/]*$/\//;
  system "mkdir", "-p", $parent;

  system "cp", "-a", "--reflink=auto", "$srcDir/$img", "$destDir/$img";

  system $jheadExec, "-autorot", "$destDir/$img";

  my ($oldX, $oldY) = getPix "$destDir/$img";
  my ($newX, $newY) = ($targetX, $targetY);

  if($orientSwap and not isOrientMatch $oldX, $oldY){
    ($newX, $newY) = ($newY, $newX);
  }

  my $percent = getResizePercent $newX, $newY, $oldX, $oldY;
  runConvert "$destDir/$img", "-resize", "$percent%";

  pad "$destDir/$img", $newX, $newY;

  open INFO, "> $destDir/$img.info";
  print INFO $statInfo;
  close INFO;

  system "touch", "$destDir/$img", "--reference=$srcDir/$img";
  system "touch", "$destDir/$img.info", "--reference=$srcDir/$img";
  print " finished $destDir/$img\n";
}

sub isOrientMatch($$){
  my ($oldX, $oldY) = @_;
  return getOrientation($oldX, $oldY) eq $targetOrientation;
}

sub getResizePercent($$$$){
  my ($newX, $newY, $oldX, $oldY) = @_;
  my $ratio;

  my $ratio1 = $newX / $oldX;
  my $ratio2 = $newY / $oldY;
  $ratio = $ratio1 < $ratio2 ? $ratio1 : $ratio2;

  my $percent = sprintf '%.5f', $ratio*100;

  return $percent;
}

sub pad($$$){
  my ($file, $newX, $newY) = @_;

  if($pad){
    runConvert $file,
      "-gravity", $padGravity,
      "-background", $padColor,
      "-extent", "${newX}x${newY}",
      ;
  }
}

sub runConvert($@){
  my ($file, @args) = @_;

  my $tmp = $file;
  $tmp =~ s/\//_/g;
  $tmp = "/tmp/pixmirror-" . time() . "-$tmp";
  die "$tmp already exists!\n" if -f $tmp;
  system $convertExec, @args, $file, $tmp;
  die "failed to run convert on $file {@args}\n" if $? != 0 or not -f $tmp;

  system "rm", $file;
  system "mv", $tmp, $file;
}

sub getOrientation($$){
  my ($x, $y) = @_;
  return $x > $y ? "landscape" : "portrait";
}

&main(@ARGV);
