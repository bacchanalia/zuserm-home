#!/usr/bin/perl
use strict;
use warnings;

my $url = 'https://en.wikipedia.org/wiki/List_of_Escape_Pod_episodes';
my $epDir = "$ENV{HOME}/escapepod";
my $csvDelim = ';';

sub htmlCacheFile($);
sub ensureHtmlCache($$);
sub checkHtmlCache($);
sub attemptPutHtmlCache($$);
sub readHtmlCache($);
sub getMP3Url($);
sub browserLoadArticle($);
sub readAttCache($);
sub writeAttCache($$);
sub downloadMP3File($$$$);
sub tagMP3File($$);
sub newMP3FileName($);

sub parseTableRow($$);
sub padl($$);
sub maxLen(@);

sub csv($);
sub cell($);

sub run(@);

my $cmds = join "|", qw(
  --csv --url --mp3url --mp3filename --download --download-only --tag
);
my $usage = "Usage:
  $0 [$cmds [EPNUM EPNUM ..]]
    Fetch episode list from $url.
    Parse it, and print certain info.

    --csv {default if no args specified}
      Print episode info in CSV with delim=$csvDelim
    --url
      Print the article url for each EPNUM, using the links in the above url.
    --mp3url
      Print the download URL, parsed from the escape pod article HTML.
      HTML is fetched using curl/wget and cached in $epDir/htmlCache/EPNUM.html
    --mp3filename
      Same as --mp3url, but only print the filename
    --download
      Get mp3url and download it with axel, then --tag it as below.
      Skip an EPNUM if the mp3filename
        or a file named \"###EPNUM TITLE.mp3\"
        is already present in the current dir.
    --download-only
      Same as --download, except do not --tag after downloading
    --tag
      Set tags and rename files.
      Gets mp3filename, assume it is in current dir.
      If mp3filename is not present, use the target name.

      Remove all id3 tags from the file, and set new tags.
      Uses 'id3v2' and 'mid3iconv'.
        title = \"TITLE\"
        author = \"AUTHOR [READER]\"
        tracknumber = \"EPNUM\"
        album = \"Escape Pod\"
      Rename the file from mp3filename => \"###EPNUM TITLE.mp3\"
      {with /s removed}

  EPNUM: escape pod episode number. if none are specified, all are used.
";

sub main(@){
  my $cmd = shift;
  $cmd = '--csv' if not defined $cmd;
  die $usage if $cmd !~ /^($cmds)$/;

  my @nums = @_;
  die $usage if (grep {$_ !~ /^\d+$/} @nums) > 0;

  my %okNums = map {$_+0 => 1} @nums;


  my $html = `wget -O - $url 2>/dev/null`;
  my @epNums;
  my @tableRows;
  while($html =~ /<tr>\s*<td>(\d+)<\/td>.*?<\/tr>/gs){
    push @tableRows, $&;
    push @epNums, $1;
  }

  my $maxLen = maxLen @epNums;

  my $articleUrlCache = readAttCache 'article-urls';
  my $eps = {};
  for my $tableRow(@tableRows){
    my $ep = parseTableRow $tableRow, $maxLen;
    next if keys %okNums > 0 and not defined $okNums{$$ep{number}+0};
    my $epNum = $$ep{number};
    $$eps{$epNum} = $ep;
    $$articleUrlCache{$epNum+0} = $$ep{articleUrl};
  }
  writeAttCache 'article-urls', $articleUrlCache;
  my $exitCode = 0;

  if($cmd eq '--csv'){
    for my $epNum(sort keys %$eps){
      print csv($$eps{$epNum}) . "\n";
    }
  }elsif($cmd eq '--url'){
    for my $epNum(sort keys %$eps){
      print "$$eps{$epNum}{articleUrl}\n";
    }
  }elsif($cmd =~ /^(--mp3url|--mp3filename|--download|--download-only|--tag)/){
    for my $epNum(sort keys %$eps){
      if(ensureHtmlCache $epNum, $$eps{$epNum}{articleUrl}){
        my $mp3Url = getMP3Url $epNum;
        my $mp3FileName = $1 if $mp3Url =~ /([^\/]*\.mp3)$/;
        if($cmd eq '--mp3url'){
          print "$mp3Url\n";
        }elsif($cmd eq '--mp3filename'){
          print "$mp3FileName\n";
        }elsif($cmd eq '--download'){
          downloadMP3File($mp3Url, $mp3FileName, $$eps{$epNum}, 1);
        }elsif($cmd eq '--download-only'){
          downloadMP3File($mp3Url, $mp3FileName, $$eps{$epNum}, 0);
        }elsif($cmd eq '--tag'){
          tagMP3File($mp3FileName, $$eps{$epNum});
        }
      }else{
        print "   ERROR: $epNum\n";
        $exitCode = 1;
      }
    }
  }
  exit $exitCode;
}

sub htmlCacheFile($){
  my $epNum = shift;
  return "$epDir/htmlCache/$epNum.html";
}

sub ensureHtmlCache($$){
  my ($epNum, $articleUrl) = @_;
  my $attempts;
  return 1 if checkHtmlCache $epNum;

  $attempts = 10;
  while($attempts > 0 and not checkHtmlCache $epNum){
    $attempts--;
    attemptPutHtmlCache $epNum, $articleUrl;
  }
  if(not checkHtmlCache $epNum){
    browserLoadArticle $articleUrl;
  }
  $attempts = 10;
  while($attempts > 0 and not checkHtmlCache $epNum){
    $attempts--;
    attemptPutHtmlCache $epNum, $articleUrl;
  }

  return checkHtmlCache $epNum;
}

sub checkHtmlCache($){
  my $epNum = shift;
  my $cacheFile = htmlCacheFile $epNum;
  return 0 if not -e $cacheFile;
  my $html = `cat $cacheFile`;
  if($html =~ /href="([^"]*\.mp3)"/){
    return 1;
  }else{
    run "rm", "-f", $cacheFile;
    return 0;
  }
}

sub attemptPutHtmlCache($$){
  my ($epNum, $articleUrl) = @_;
  my $cacheFile = htmlCacheFile $epNum;

  system "curl -L \"$articleUrl\" -o \"$cacheFile\" 2>/dev/null";
  return 1 if checkHtmlCache $epNum;

  system "wget \"$articleUrl\" -O \"$cacheFile\" 2>/dev/null";
  return 1 if checkHtmlCache $epNum;

  return 0;
}

sub readHtmlCache($){
  my $epNum = shift;
  my $cacheFile = htmlCacheFile $epNum;
  die "Missing html file for $epNum\n" if not checkHtmlCache $epNum;
  return `cat $cacheFile`;
}

sub browserLoadArticle($){
  my $articleUrl = shift;
  system "uzbl $articleUrl >/dev/null 2>/dev/null &";
  sleep 5;
  system "pkill", "-f", "uzbl.*$articleUrl";
}

sub readAttCache($){
  my $name = shift;
  my $cacheFile = "$epDir/$name";
  my @lines = `cat $cacheFile 2>/dev/null`;
  my $cache = {};
  for my $line(@lines){
    if($line =~ /^(\d+)\s+(.*)$/){
      $$cache{$1+0} = $2;
    }
  }
  return $cache;
}

sub writeAttCache($$){
  my ($name, $cache) = @_;
  my $cacheFile = "$epDir/$name";
  my $s = '';
  open FH, "> $cacheFile" or die "Couldnt write to $cacheFile\n";
  for my $epNum(sort {$a <=> $b} keys %$cache){
    print FH sprintf "%03d %s\n", $epNum, $$cache{$epNum};
  }
  close FH;
}

sub getMP3Url($){
  my $epNum = shift;
  my $html = readHtmlCache $epNum;
  if($html !~ /href="([^"]*\.mp3)"/){
    die "Could not read mp3 url for $epNum\n";
  }
  return $1;
}

sub downloadMP3File($$$$){
  my ($mp3Url, $mp3FileName, $ep, $tagFile) = @_;
  my $newFileName = newMP3FileName $ep;
  if(-e $mp3FileName or -e $newFileName){
    print "  skipping $$ep{number}..\n";
  }else{
    run "axel", $mp3Url;
    die " downloading failed\n" if $? != 0;
    tagMP3File $mp3FileName, $ep if $tagFile;
  }
}
sub tagMP3File($$){
  my ($mp3FileName, $ep) = @_;
  my $oldFileName = $mp3FileName;
  my $newFileName = newMP3FileName $ep;

  if(not -e $oldFileName and not -e $newFileName){
    print "   ERROR: missing $oldFileName or $newFileName\n";
    return;
  }
  $oldFileName = $newFileName if not -e $oldFileName;

  run "id3v2", "--delete-all", $oldFileName;
  die "error removing id3 tags for $$ep{number}\n" if $? != 0;

  run "id3v2",
    "--TIT2", $$ep{title},
    "--TPE1", $$ep{author},
    "--TPE2", $$ep{reader},
    "--TRCK", $$ep{number}+0,
    "--TALB", "Escape Pod",
    "--TYER", $$ep{date},
    $oldFileName;
  die "error setting id3 tags for $$ep{number}\n" if $? != 0;

  run "mid3iconv", $oldFileName;
  die "error setting encoding to unicode\n" if $? != 0;

  if($oldFileName ne $newFileName){
    run "mv", "--no-clobber", $oldFileName, $newFileName;
    die "error renaming file\n" if $? != 0;
  }
}
sub newMP3FileName($){
  my $ep = shift;
  my $newFileName = "$$ep{number} $$ep{title}.mp3";
  $newFileName =~ s/\//_/g;
  return $newFileName;
}

sub parseTableRow($$){
  my $tr = shift;
  my $maxLen = shift;

  $tr =~ /href="(http:\/\/escapepod.org\/(\d+\/\d+\/\d+)\/[^"]*)"/;
  my $articleUrl = $1;
  my $date = $2;

  $tr =~ s/<sup.*?<\/sup>//gsxi;
  $tr =~ s/\n/ /g;
  $tr =~ s/<a [^<>]* >  \s*(.*?)\s*  < \s* \/ \s* a \s* >/$1/gsxi;
  $tr =~ s/\s*<td [^<>]* >  \s*(.*?)\s*  < \s* \/ \s* td \s* >\s*/<>$1/gsxi;
  $tr =~ s/^\s*<tr>\s*<>(.*)<>\s*EPF\s*<\/tr>\s*$/$1/;
  if($tr =~ /^(\d+)<>([^<]*)<>([^<]*)<>([^<]*)<>([^<]*)<>([^<]*)$/){
    return {
      number => padl($maxLen, $1),
      title => $2,
      author => $3,
      reader => $4,
      rating => $5,
      duration => $6,
      articleUrl => $articleUrl,
      date => $date,
    };
  }else{
    die "fucked up episode: $tr\n";
  }
}
sub padl($$){
  my ($len, $n) = @_;
  return ('0'x($len - length $n)) . $n;
}
sub maxLen(@){
  my $maxLen = 0;
  for my $s(@_){
   $maxLen = length $s if length $s > $maxLen; 
  }
  return $maxLen;
}


sub csv($){
  my $ep = shift;
  my @cols = (
    cell $$ep{number},
    cell $$ep{title},
    cell $$ep{author},
    cell $$ep{reader},
    cell $$ep{date},
    cell $$ep{articleUrl},
  );
  return join ($csvDelim, @cols);
}
sub cell($){
  my $cell = shift;
  $cell =~ s/\&amp;/\&/g;
  if($cell =~ /\Q$csvDelim\E/ or $cell =~ /\Q"\E/){
    $cell =~ s/"/""/g;
    $cell = "\"$cell\"";
    return $cell;
  }else{
    return $cell;
  }
}

sub run(@){
  print "@_\n";
  system @_;
}

&main(@ARGV);
